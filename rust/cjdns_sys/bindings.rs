/* automatically generated by rust-bindgen 0.55.1 */
extern "C" {
    pub fn Assert_failure(format: *const ::std::os::raw::c_char, ...);
}

pub type Allocator_OnFreeCallback = ::std::option::Option<
    unsafe extern "C" fn(job: *mut Allocator_OnFreeJob) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Allocator_OnFreeJob {
    pub callback: Allocator_OnFreeCallback,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Allocator_OnFreeJob() {
    assert_eq!(
        ::std::mem::size_of::<Allocator_OnFreeJob>(),
        16usize,
        concat!("Size of: ", stringify!(Allocator_OnFreeJob))
    );
    assert_eq!(
        ::std::mem::align_of::<Allocator_OnFreeJob>(),
        8usize,
        concat!("Alignment of ", stringify!(Allocator_OnFreeJob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Allocator_OnFreeJob>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_OnFreeJob),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Allocator_OnFreeJob>())).userData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_OnFreeJob),
            "::",
            stringify!(userData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Allocator {
    pub fileName: *const ::std::os::raw::c_char,
    pub lineNum: ::std::os::raw::c_int,
    pub isFreeing: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Allocator() {
    assert_eq!(
        ::std::mem::size_of::<Allocator>(),
        16usize,
        concat!("Size of: ", stringify!(Allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<Allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(Allocator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Allocator>())).fileName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator),
            "::",
            stringify!(fileName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Allocator>())).lineNum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator),
            "::",
            stringify!(lineNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Allocator>())).isFreeing as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator),
            "::",
            stringify!(isFreeing)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Allocator_Allocation {
    pub size: usize,
}
#[test]
fn bindgen_test_layout_Allocator_Allocation() {
    assert_eq!(
        ::std::mem::size_of::<Allocator_Allocation>(),
        8usize,
        concat!("Size of: ", stringify!(Allocator_Allocation))
    );
    assert_eq!(
        ::std::mem::align_of::<Allocator_Allocation>(),
        8usize,
        concat!("Alignment of ", stringify!(Allocator_Allocation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Allocator_Allocation>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Allocator_Allocation),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn Allocator_getChild(
        alloc: *mut Allocator,
        childNumber: ::std::os::raw::c_int,
    ) -> *mut Allocator;
}
extern "C" {
    pub fn Allocator_getAllocation(
        alloc: *mut Allocator,
        allocNum: ::std::os::raw::c_int,
    ) -> *mut Allocator_Allocation;
}
extern "C" {
    pub fn Allocator__malloc(
        allocator: *mut Allocator,
        length: ::std::os::raw::c_ulong,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Allocator__calloc(
        alloc: *mut Allocator,
        length: ::std::os::raw::c_ulong,
        count: ::std::os::raw::c_ulong,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Allocator__realloc(
        allocator: *mut Allocator,
        original: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Allocator__clone(
        allocator: *mut Allocator,
        toClone: *const ::std::os::raw::c_void,
        length: ::std::os::raw::c_ulong,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Allocator__child(
        alloc: *mut Allocator,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    ) -> *mut Allocator;
}
extern "C" {
    pub fn Allocator__free(
        alloc: *mut Allocator,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Allocator__onFree(
        alloc: *mut Allocator,
        callback: Allocator_OnFreeCallback,
        context: *mut ::std::os::raw::c_void,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut Allocator_OnFreeJob;
}
extern "C" {
    pub fn Allocator_cancelOnFree(toRemove: *mut Allocator_OnFreeJob) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Allocator_onFreeComplete(onFreeJob: *mut Allocator_OnFreeJob);
}
extern "C" {
    pub fn Allocator__adopt(
        parentAlloc: *mut Allocator,
        alloc: *mut Allocator,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Allocator__disown(
        parentAlloc: *mut Allocator,
        allocToDisown: *mut Allocator,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Allocator_setCanary(alloc: *mut Allocator, value: usize);
}
extern "C" {
    pub fn Allocator_bytesAllocated(allocator: *mut Allocator) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn Allocator_snapshot(alloc: *mut Allocator, includeAllocations: ::std::os::raw::c_int);
}
pub type Allocator_Provider = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        original: *mut Allocator_Allocation,
        size: ::std::os::raw::c_ulong,
        group: *mut Allocator,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn Allocator_new(
        sizeLimit: ::std::os::raw::c_ulong,
        provider: Allocator_Provider,
        providerContext: *mut ::std::os::raw::c_void,
        fileName: *const ::std::os::raw::c_char,
        lineNum: ::std::os::raw::c_int,
    ) -> *mut Allocator;
}
pub const Error_e_Error_NONE: Error_e = 0;
pub const Error_e_Error_MALFORMED_ADDRESS: Error_e = 1;
pub const Error_e_Error_FLOOD: Error_e = 2;
pub const Error_e_Error_LINK_LIMIT_EXCEEDED: Error_e = 3;
pub const Error_e_Error_OVERSIZE_MESSAGE: Error_e = 4;
pub const Error_e_Error_RUNT: Error_e = 5;
pub const Error_e_Error_AUTHENTICATION: Error_e = 6;
pub const Error_e_Error_INVALID: Error_e = 7;
pub const Error_e_Error_UNDELIVERABLE: Error_e = 8;
pub const Error_e_Error_LOOP_ROUTE: Error_e = 9;
pub const Error_e_Error_RETURN_PATH_INVALID: Error_e = 10;
pub const Error_e_Error_UNHANDLED: Error_e = 11;
pub const Error_e_Error_OVERFLOW: Error_e = 12;
pub const Error_e_Error_INTERNAL: Error_e = 13;
pub type Error_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Error_s {
    pub e: Error_e,
}
#[test]
fn bindgen_test_layout_Error_s() {
    assert_eq!(
        ::std::mem::size_of::<Error_s>(),
        4usize,
        concat!("Size of: ", stringify!(Error_s))
    );
    assert_eq!(
        ::std::mem::align_of::<Error_s>(),
        4usize,
        concat!("Alignment of ", stringify!(Error_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Error_s>())).e as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Error_s),
            "::",
            stringify!(e)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Er_Ret {
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Er_Ret() {
    assert_eq!(
        ::std::mem::size_of::<Er_Ret>(),
        8usize,
        concat!("Size of: ", stringify!(Er_Ret))
    );
    assert_eq!(
        ::std::mem::align_of::<Er_Ret>(),
        8usize,
        concat!("Alignment of ", stringify!(Er_Ret))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Er_Ret>())).message as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Er_Ret),
            "::",
            stringify!(message)
        )
    );
}
extern "C" {
    pub fn Er__raise(
        file: *mut ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        alloc: *mut Allocator,
        format: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut Er_Ret;
}
extern "C" {
    pub fn Er__assertFail(er: *mut Er_Ret);
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
extern "C" {
    pub fn Bits_log2x64_stupid(number: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Bits_memmem(
        haystack: *const ::std::os::raw::c_void,
        haystackLen: size_t,
        needle: *const ::std::os::raw::c_void,
        needleLen: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Message {
    pub length: i32,
    pub padding: i32,
    pub bytes: *mut u8,
    pub capacity: i32,
    pub associatedFd: ::std::os::raw::c_int,
    pub currentIface: *mut Iface,
    pub alloc: *mut Allocator,
}
#[test]
fn bindgen_test_layout_Message() {
    assert_eq!(
        ::std::mem::size_of::<Message>(),
        40usize,
        concat!("Size of: ", stringify!(Message))
    );
    assert_eq!(
        ::std::mem::align_of::<Message>(),
        8usize,
        concat!("Alignment of ", stringify!(Message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).padding as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).capacity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).associatedFd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(associatedFd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).currentIface as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(currentIface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Message>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Message),
            "::",
            stringify!(alloc)
        )
    );
}
extern "C" {
    pub fn Message_new(
        messageLength: u32,
        amountOfPadding: u32,
        alloc: *mut Allocator,
    ) -> *mut Message;
}
extern "C" {
    pub fn Message_setAssociatedFd(msg: *mut Message, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Message_getAssociatedFd(msg: *mut Message) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Message_clone(toClone: *mut Message, alloc: *mut Allocator) -> *mut Message;
}
extern "C" {
    pub fn Message_copyOver(output: *mut Message, input: *mut Message, allocator: *mut Allocator);
}
pub type Iface_Callback = ::std::option::Option<
    unsafe extern "C" fn(message: *mut Message, thisInterface: *mut Iface) -> Error_s,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iface {
    pub send: Iface_Callback,
    pub currentMsg: *mut Message,
    pub connectedIf: *mut Iface,
}
#[test]
fn bindgen_test_layout_Iface() {
    assert_eq!(
        ::std::mem::size_of::<Iface>(),
        24usize,
        concat!("Size of: ", stringify!(Iface))
    );
    assert_eq!(
        ::std::mem::align_of::<Iface>(),
        8usize,
        concat!("Alignment of ", stringify!(Iface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Iface>())).send as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Iface),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Iface>())).currentMsg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Iface),
            "::",
            stringify!(currentMsg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Iface>())).connectedIf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Iface),
            "::",
            stringify!(connectedIf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCountWrapper {
    pub internal: *mut Iface,
    pub external: *mut Iface,
}
#[test]
fn bindgen_test_layout_CCountWrapper() {
    assert_eq!(
        ::std::mem::size_of::<CCountWrapper>(),
        16usize,
        concat!("Size of: ", stringify!(CCountWrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<CCountWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(CCountWrapper))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCountWrapper>())).internal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCountWrapper),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCountWrapper>())).external as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCountWrapper),
            "::",
            stringify!(external)
        )
    );
}
extern "C" {
    pub fn countwrapper_create(alloc: *mut Allocator) -> CCountWrapper;
}
